package Analizador;
import java_cup.runtime.Symbol;
import java_cup.runtime.XMLElement;

parser code
{:

    public void syntax_error(Symbol cur_token) {
        System.out.println(" Se esperaban: ");
        String esperados = "";
        for (int i = 0; i < expected_token_ids().size(); i++){
            esperados += symbl_name_from_id(expected_token_ids().get(i))+"-";
        }
        System.out.print(esperados+", pero se encontro "+cur_token.value+" en la linea"+cur_token.right+" y en la columna"+cur_token.left);
    }

    public void report_fatal_error(String message, Object info) {
        System.out.println("reportfatal "+message+info);
    }
    
    public void report_fatal_error(Symbol cur) {
        System.out.println("unrecovered_syntax_error");
    }

    public void imp(String texto){
        System.out.println(texto);
    }

:};

terminal PISTA, EXT, ENTERO, DECIMAL, BOOLEAN, CHAR, CADENA, TRUE, FALSE, KEEP, VAR,
    SI, SINO, SWITCH, CASO, SALIR, CONT, DEFAULT, PARA, MIENTRAS, HACER, RETORNA, REPRODUCIR,
    NOTAS, ESPERAR, ORDENAR, ASC, DESC, PAR, IMPAR, PRIMOS, SUMARIZAR, LONG, MSG, PRINCIPAL,
    IGUAL, DIFF, MAYOR, MENOR, MAYOR_I, MENOR_I, NULO, AND, NAND, OR, XOR, NOR, NOT, SUMA, RESTA,
    POR, ENTRE, MOD, POT, DEC, INC, SUMA_S, COR_A, COR_C, DOS_P, COMA, LLAVE_A, LLAVE_C, SAL, ARREGLO,
    ID, STRING, CARACTER, PAR_A, PAR_C, NUMERO, NUMERO_D, ASIGNAR, ERRORLEX, INDENT, DEDENT, UMINUS, PUNTOC;

non terminal inicio, si, sino, bloque, op, op2, instrucciones, instruccion, declaracion, declaraciones, sinosi, condicion,
    switch, pista, pistas, extiende, ids, valor_puntual, expresion, booleano, comparador, binario, default, casos, caso, tipo,
    asignacion, asignar, asigna, para, paso, hacer, mientras, reproducir, esperar, mensaje, lista_declaracion,
    metodo, parametros, parametro, llamada, texto, param, condicional, tipo_retorno, dimensiones, dimension, items, item, 
    asignar_arreglo;

precedence left SUMA, RESTA;
precedence left POR, ENTRE, MOD;
precedence left POT;
precedence right UMINUS;
precedence left OR, NOR, XOR;
precedence left AND, NAND;
precedence right NOT;
precedence left IGUAL, DIFF, MENOR, MENOR_I, MAYOR, MAYOR_I;

start with inicio;

inicio::=
    pistas {: imp("todo bien carnalin"); :}
;

pistas::=
    pistas pista
|   pista
;

pista::=
    PISTA ID extiende INDENT lista_declaracion DEDENT
;

lista_declaracion::=
    lista_declaracion declaraciones
|   declaraciones
;

declaraciones::=
    declaracion
|   metodo
;

metodo::=
    KEEP tipo ID PAR_A param PAR_C INDENT instrucciones DEDENT
|   tipo ID PAR_A param PAR_C INDENT instrucciones DEDENT
|   ID PAR_A param PAR_C INDENT instrucciones DEDENT
|   KEEP ID PAR_A param PAR_C INDENT instrucciones DEDENT
;

param::=
|   parametros
;

parametros::=
    parametros COMA parametro
|   parametro
;

parametro::=
    tipo ID
;

extiende::=
|   EXT ids
;

ids::=
    ids COMA ID
|   ID
;

instrucciones::=
|   instrucciones instruccion
;

instruccion::=
   declaracion
|   asignacion
|   CONT
|   SALIR
|   RETORNA tipo_retorno
|   para
|   si
|   mientras
|   hacer
|   switch
|   reproducir
|   esperar
|   error
|   mensaje
;

tipo_retorno::=
    condicion
|   expresion
;

si::=
    SI PAR_A condicional PAR_C INDENT instrucciones DEDENT
|   SI PAR_A condicional PAR_C INDENT instrucciones DEDENT SINO INDENT instrucciones DEDENT
|   SI PAR_A condicional PAR_C INDENT instrucciones DEDENT SINO si 
;

declaracion::=
   KEEP VAR tipo ids asignar
|   VAR tipo ids asignar
|   KEEP VAR tipo ARREGLO ids dimensiones asignar_arreglo
|   VAR tipo ARREGLO ids dimensiones asignar_arreglo
;

asignar_arreglo::=
|   ASIGNAR LLAVE_A items LLAVE_C
;

items::=
    items COMA item
|   item
;

item::=
    expresion
|   LLAVE_A items LLAVE_C
;

dimensiones::=
    dimensiones dimension
|   dimension
;

dimension::=
    COR_A expresion COR_C
;

para::=
    PARA PAR_A asigna PUNTOC condicional PUNTOC NUMERO paso PAR_C INDENT instrucciones DEDENT
;

paso::=
    INC
|   DEC
;

asigna::=
    ENTERO ID ASIGNAR NUMERO
|   ID
;


asignar::=
|   ASIGNAR expresion
;

asignacion::=
    ID ASIGNAR expresion
|    ID dimensiones ASIGNAR tipo_retorno
;

tipo::=
    ENTERO
|   DECIMAL
|   CADENA
|   BOOLEAN 
|   CHAR
;

switch::=
    SWITCH PAR_A ID PAR_C INDENT casos DEDENT
|   SWITCH PAR_A ID PAR_C INDENT casos default DEDENT
|   SWITCH PAR_A ID PAR_C INDENT default DEDENT
;

casos::=
    casos caso
|   caso
;

caso::=
    CASO valor_puntual INDENT instrucciones DEDENT
;

default::=
    DEFAULT INDENT instrucciones DEDENT
;

valor_puntual::=
    NUMERO
|   STRING
|   CARACTER
|   booleano
|   NUMERO_D
;

condicion::=
   PAR_A condicion PAR_C
|   expresion MAYOR expresion
|   expresion MENOR expresion
|   expresion MENOR_I expresion
|   expresion MAYOR_I expresion
|   expresion IGUAL expresion
|   expresion DIFF expresion
|   NOT condicion
|   NULO ID
|   condicion AND condicion
|   condicion OR condicion
|   condicion XOR condicion
|   condicion NAND condicion
|   condicion NOR condicion
;

booleano::=
    TRUE
|   FALSE
;

expresion::=
   expresion SUMA expresion {: imp("Encuentra suma"); :}
|   expresion RESTA expresion {: imp("Encuentra menos"); :}
|   expresion POR expresion {: imp("Encuentra por"); :}
|   expresion ENTRE expresion {: imp("Encuentra division"); :}
|   expresion POT expresion {: imp("Encuentra potencia"); :}
|   expresion MOD expresion {: imp("Encuentra modulo"); :}
|   RESTA expresion {: imp("Encuentra simbolo menos"); :}
%prec UMINUS
|   valor_puntual {: imp("Encuentra valor"); :}
|   PAR_A expresion PAR_C {: imp("Encuentra parentesis"); :}
|   ID {: imp("Encuentra variable"); :}
|   llamada {: imp("Encuentra llamada"); :}
;

llamada::=
    ID PAR_A parametros PAR_C
;

mientras::=
    MIENTRAS PAR_A condicional PAR_C INDENT instrucciones DEDENT
;

hacer::=
    HACER INDENT instrucciones DEDENT MIENTRAS PAR_A condicional PAR_C
;

reproducir::=
    REPRODUCIR PAR_A NOTAS COMA expresion COMA expresion COMA expresion PAR_C
;

esperar::=
    ESPERAR PAR_A expresion COMA expresion PAR_C
;

mensaje::=
    MSG PAR_A texto PAR_C 
;

texto::=
    texto SUMA valor_puntual
|   valor_puntual
;

condicional::=
    condicion
|   booleano
;

