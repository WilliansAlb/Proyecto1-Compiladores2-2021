package Analizador;
import java_cup.runtime.Symbol;
import java_cup.runtime.XMLElement;
import Interprete.*;

parser code
{:

    public Expresion sumando;

    public void syntax_error(Symbol cur_token) {
        System.out.println(" Se esperaban: ");
        String esperados = "";
        for (int i = 0; i < expected_token_ids().size(); i++){
            esperados += symbl_name_from_id(expected_token_ids().get(i))+"-";
        }
        System.out.print(esperados+", pero se encontro "+cur_token.value+" en la linea"+cur_token.right+" y en la columna"+cur_token.left);
    }

    public void report_fatal_error(String message, Object info) {
        System.out.println("reportfatal "+message+info);
    }
    
    public void report_fatal_error(Symbol cur) {
        System.out.println("unrecovered_syntax_error");
    }

    public void imp(String texto){
        System.out.println(texto);
    }

:};

terminal PISTA, EXT, ENTERO, DECIMAL, BOOLEAN, CHAR, CADENA, TRUE, FALSE, KEEP, VAR,
    SI, SINO, SWITCH, CASO, SALIR, CONT, DEFAULT, PARA, MIENTRAS, HACER, RETORNA, REPRODUCIR,
    NOTAS, ESPERAR, ORDENAR, ASC, DESC, PAR, IMPAR, PRIMOS, SUMARIZAR, LONG, MSG, PRINCIPAL,
    IGUAL, DIFF, MAYOR, MENOR, MAYOR_I, MENOR_I, NULO, AND, NAND, OR, XOR, NOR, NOT, SUMA, RESTA,
    POR, ENTRE, MOD, POT, DEC, INC, SUMA_S, COR_A, COR_C, DOS_P, COMA, LLAVE_A, LLAVE_C, SAL, ARREGLO,
    ID, STRING, CARACTER, PAR_A, PAR_C, NUMERO, NUMERO_D, ASIGNAR, ERRORLEX, INDENT, DEDENT, UMINUS, PUNTOC;

non terminal inicio, si, instrucciones, instruccion, declaracion, declaraciones, condicion, param2, parametros2,
    switch, pista, pistas, extiende, ids, expresion, booleano, default, casos, caso, tipo,
    asignacion, asignar, asigna, para, paso, hacer, mientras, reproducir, esperar, mensaje, lista_declaracion,
    metodo, parametros, parametro, llamada, texto, param, condicional, tipo_retorno, dimensiones, dimension, items, item, 
    asignar_arreglo, metodos_retorno, forma_ordenar, arreglo_cadena, arreglo_ordenar, incremento, decremento, suma_simplificada;

non terminal Expresion expresion2;
non terminal Primitivo valor_puntual;


precedence left SUMA, RESTA;
precedence left POR, ENTRE, MOD;
precedence left POT;
precedence right UMINUS;
precedence left OR, NOR, XOR;
precedence left AND, NAND;
precedence right NOT;
precedence left IGUAL, DIFF, MENOR, MENOR_I, MAYOR, MAYOR_I;
precedence right NULO;

start with inicio;

inicio::=
    pistas {: imp("todo bien carnalin"); :}
;

pistas::=
    pistas pista
|   pista
;

pista::=
    PISTA ID extiende INDENT lista_declaracion DEDENT
;

lista_declaracion::=
    lista_declaracion declaraciones
|   declaraciones
;

declaraciones::=
    declaracion
|   metodo
;

metodo::=
    KEEP tipo ID PAR_A param PAR_C INDENT instrucciones DEDENT
|   tipo ID PAR_A param PAR_C INDENT instrucciones DEDENT
|   ID PAR_A param PAR_C INDENT instrucciones DEDENT
|   KEEP ID PAR_A param PAR_C INDENT instrucciones DEDENT
|   KEEP PRINCIPAL PAR_A param PAR_C INDENT instrucciones DEDENT
|   PRINCIPAL PAR_A param PAR_C INDENT instrucciones DEDENT
; 

param::=
|   parametros
;

parametros::=
    parametros COMA parametro
|   parametro
;

parametro::=
    tipo ID
;

extiende::=
|   EXT ids
;

ids::=
    ids COMA ID
|   ID
;

instrucciones::=
|   instrucciones instruccion
;

instruccion::=
   declaracion
|   metodos_retorno
|   suma_simplificada
|   incremento
|   decremento
|   llamada
|   asignacion
|   CONT
|   SALIR
|   RETORNA expresion2
|   para
|   si
|   mientras
|   hacer
|   switch
|   reproducir
|   esperar
|   error
|   mensaje
;

suma_simplificada::=
    ID SUMA_S expresion
;

incremento::=
    ID INC
;

decremento::=
    ID DEC
;

tipo_retorno::=
    condicion
|   expresion
;

si::=
    SI PAR_A expresion2 PAR_C INDENT instrucciones DEDENT
|   SI PAR_A expresion2 PAR_C INDENT instrucciones DEDENT SINO INDENT instrucciones DEDENT
|   SI PAR_A expresion2 PAR_C INDENT instrucciones DEDENT SINO si 
;

declaracion::=
   KEEP VAR tipo ids asignar
|   VAR tipo ids asignar
|   KEEP VAR tipo ARREGLO ids dimensiones asignar_arreglo
|   VAR tipo ARREGLO ids dimensiones asignar_arreglo
;

asignar_arreglo::=
|   ASIGNAR LLAVE_A items LLAVE_C
;

items::=
    items COMA item
|   item
;

item::=
    expresion
|   LLAVE_A items LLAVE_C
;

dimensiones::=
    dimensiones dimension
|   dimension
;

dimension::=
    COR_A expresion COR_C
;

para::=
    PARA PAR_A asigna PUNTOC expresion2 PUNTOC NUMERO paso PAR_C INDENT instrucciones DEDENT
;

paso::=
    INC
|   DEC
;

asigna::=
    ENTERO ID ASIGNAR NUMERO
|   ID
;


asignar::=
|   ASIGNAR expresion2
;

asignacion::=
    ID ASIGNAR expresion2:e1 {: sumando = e1; :}
|    ID dimensiones ASIGNAR expresion2:e1 {: sumando = e1; :}
;

tipo::=
    ENTERO
|   DECIMAL
|   CADENA
|   BOOLEAN 
|   CHAR
;

switch::=
    SWITCH PAR_A ID PAR_C INDENT casos DEDENT
|   SWITCH PAR_A ID PAR_C INDENT casos default DEDENT
|   SWITCH PAR_A ID PAR_C INDENT default DEDENT
;

casos::=
    casos caso
|   caso
;

caso::=
    CASO valor_puntual INDENT instrucciones DEDENT
;

default::=
    DEFAULT INDENT instrucciones DEDENT
;

valor_puntual::=
    NUMERO:e1 {: RESULT = new Primitivo("numero",(java_cup.runtime.Symbol) CUP$parser$stack.peek(),Integer.parseInt(e1.toString())); :}
|   STRING:e1 {: RESULT = new Primitivo("string",(java_cup.runtime.Symbol) CUP$parser$stack.peek(),e1.toString()); :}
|   CARACTER:e1 {: RESULT = new Primitivo("caracter",(java_cup.runtime.Symbol) CUP$parser$stack.peek(),e1.toString().charAt(0)); :}
|   TRUE:e1 {: RESULT = new Primitivo("boolean",(java_cup.runtime.Symbol) CUP$parser$stack.peek(),true); :}
|   FALSE:e1 {: RESULT = new Primitivo("boolean",(java_cup.runtime.Symbol) CUP$parser$stack.peek(),false); :}
|   NUMERO_D:e1 {: RESULT = new Primitivo("decimal",(java_cup.runtime.Symbol) CUP$parser$stack.peek(),Double.parseDouble(e1.toString())); :}
;

condicion::=
   PAR_A condicion PAR_C {: imp("Encuentra parentesis"); :}
|   expresion MAYOR expresion {: imp("Encuentra mayor"); :}
|   expresion MENOR expresion {: imp("Encuentra menor"); :}
|   expresion MENOR_I expresion {: imp("Encuentra menor igual"); :}
|   expresion MAYOR_I expresion {: imp("Encuentra mayor igual"); :}
|   expresion IGUAL expresion {: imp("Encuentra igual"); :}
|   expresion DIFF expresion {: imp("Encuentra diferente"); :}
|   expresion IGUAL condicion {: imp("Encuentra igual"); :}
|   expresion DIFF condicion {: imp("Encuentra diferente"); :}
|   condicion DIFF expresion {: imp("Encuentra diferente"); :}
|   condicion IGUAL expresion {: imp("Encuentra diferente"); :}
|   NOT condicion {: imp("Encuentra not"); :}
|   NOT expresion {: imp("NOT expresion"); :}
|   NULO ID {: imp("Encuentra nulo"); :}
|   condicion AND condicion {: imp("Encuentra and"); :}
|   condicion OR condicion {: imp("Encuentra or"); :}
|   condicion XOR condicion {: imp("Encuentra xor"); :}
|   condicion NAND condicion {: imp("Encuentra nand"); :}
|   condicion NOR condicion {: imp("Encuentra nor"); :}
;


booleano::=
    TRUE
|   FALSE
;

expresion::=
   expresion SUMA expresion {: imp("Encuentra suma"); :}
|   expresion RESTA expresion {: imp("Encuentra menos"); :}
|   expresion POR expresion {: imp("Encuentra por"); :}
|   expresion ENTRE expresion {: imp("Encuentra division"); :}
|   expresion POT expresion {: imp("Encuentra potencia"); :}
|   expresion MOD expresion {: imp("Encuentra modulo"); :}
|   RESTA expresion {: imp("Encuentra simbolo menos"); :}
%prec UMINUS
|   valor_puntual {: imp("Encuentra valor"); :}
|   PAR_A expresion PAR_C {: imp("Encuentra parentesis"); :}
|   ID {: imp("Encuentra variable"); :}
|   llamada {: imp("Encuentra llamada"); :}
|   ID dimensiones {: imp("Encuentra valor de arreglo"); :}
|   metodos_retorno
;

expresion2::=
   expresion2:e1 SUMA expresion2:e2 
        {: 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.SUMA);
        :}
|   expresion2:e1 RESTA expresion2:e2 {:
            imp("Encuentra menos"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.RESTA);
        :}
|   expresion2:e1 POR expresion2:e2 {: 
            imp("Encuentra por");
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.POR);
        :}
|   expresion2:e1 ENTRE expresion2:e2
        {: 
            imp("Encuentra division"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.ENTRE);
        :}
|   expresion2:e1 POT expresion2:e2
        {: 
            imp("Encuentra potencia"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.POT);
        :}
|   expresion2:e1 MOD expresion2:e2 
        {: 
            imp("Encuentra modulo"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.MOD);
        :}
|   RESTA expresion2:e1 
        {: 
            imp("Encuentra negativo"); 
            RESULT = new Expresion(e1,Expresion.Tipo_operacion.NEGATIVO);
        :}
%prec UMINUS
|   expresion2:e1 MAYOR expresion2:e2
        {: 
            imp("Encuentra mayor"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.MAYOR);
        :}
|   expresion2:e1 MENOR expresion2:e2 
        {: 
            imp("Encuentra menor"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.MENOR);
        :}
|   expresion2:e1 MENOR_I expresion2:e2 
        {: 
            imp("Encuentra menor igual"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.MENOR_I);
        :}
|   expresion2:e1 MAYOR_I expresion2:e2 
        {: 
            imp("Encuentra mayor igual"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.MAYOR_I);
        :}
|   expresion2:e1 IGUAL expresion2:e2 
        {: 
            imp("Encuentra igual"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.IGUAL);
        :}
|   expresion2:e1 DIFF expresion2:e2 
        {: 
            imp("Encuentra diferente"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.DIFF);
        :}
|   expresion2:e1 AND expresion2:e2
        {: 
            imp("Encuentra and"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.AND);
        :}
|   expresion2:e1 OR expresion2:e2 
        {: 
            imp("Encuentra or"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.OR);
        :}
|   expresion2:e1 XOR expresion2:e2 
        {: 
            imp("Encuentra xor"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.XOR);
        :}
|   expresion2:e1 NAND expresion2:e2 
        {: 
            imp("Encuentra nand"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.NAND);
        :}
|   expresion2:e1 NOR expresion2:e2 
        {: 
            imp("Encuentra nor"); 
            RESULT = new Expresion(e1,e2,Expresion.Tipo_operacion.NOR);
        :}
|   valor_puntual:e1 
        {: 
            imp("Encuentra valor"); 
            RESULT = new Expresion(e1,Expresion.Tipo_operacion.PRIMITIVO);
        :}
|   PAR_A expresion2:e1 PAR_C
        {: 
            imp("Encuentra parentesis"); 
            RESULT = e1;
        :}
|   ID:e1 
        {: 
            imp("Encuentra identificador"); 
            RESULT = new Expresion(new Variable(e1.toString(),null,null,null,e1right),Expresion.Tipo_operacion.VARIABLE);
        :}
|   llamada
        {: 
            imp("Encuentra llamada"); 
            RESULT = new Expresion(new Variable("Llamada",null,null,null,-1),Expresion.Tipo_operacion.LLAMADA);
        :}
|   ID:e1 dimensiones 
        {: 
            imp("Encuentra arreglo"); 
            RESULT = new Expresion(new Variable(e1.toString(),null,null,null,e1right),Expresion.Tipo_operacion.VARIABLE);
        :}
|   NOT expresion2:e1 
        {: 
            imp("Encuentra not"); 
            RESULT = new Expresion(e1,Expresion.Tipo_operacion.NOT);
        :}
|   NULO ID:e1
        {: 
            imp("Encuentra nulo"); 
            RESULT = new Expresion(new Variable(e1.toString(),null,null,null,e1right),Expresion.Tipo_operacion.NULO);
        :}
|   metodos_retorno 
        {: 
            imp("Encuentra metodo retorno"); 
            RESULT = new Expresion(new Variable("Metodo retorno",null,null,null,e1right),Expresion.Tipo_operacion.METODO_RETORNO);
        :}
;

metodos_retorno::=
    ORDENAR PAR_A arreglo_ordenar COMA forma_ordenar PAR_C
|   SUMARIZAR PAR_A arreglo_ordenar PAR_C
|   LONG PAR_A arreglo_cadena PAR_C
;

forma_ordenar::=
    ASC
|   DESC
|   PAR
|   IMPAR
|   PRIMOS
;

arreglo_cadena::=
    STRING
|   arreglo_ordenar
;

arreglo_ordenar::=
    ID
|   LLAVE_A items LLAVE_C
;

llamada::=
    ID PAR_A param2 PAR_C
;

param2::=
|   parametros2
;

parametros2::=
    parametros2 COMA tipo_retorno
|   tipo_retorno
;

mientras::=
    MIENTRAS PAR_A expresion2 PAR_C INDENT instrucciones DEDENT
;

hacer::=
    HACER INDENT instrucciones DEDENT MIENTRAS PAR_A expresion2 PAR_C
;

reproducir::=
    REPRODUCIR PAR_A NOTAS COMA expresion COMA expresion COMA expresion PAR_C
;

esperar::=
    ESPERAR PAR_A expresion COMA expresion PAR_C
;

mensaje::=
    MSG PAR_A texto PAR_C 
;

texto::=
    texto SUMA valor_puntual
|   valor_puntual
;

condicional::=
    condicion
|   booleano
;

